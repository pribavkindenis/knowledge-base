# Манипуляции с битами

[<< Алгоритмы](./content.md)

## Битовые операции

* **NOT (`~a`)**: логическое отрицание
* **AND (`a & b`)**: логическая конъюнкция
* **OR (`a | b`)**: логическая дизъюнкция
* **XOR (`a ^ b`)**: логическая исключающая дизъюнкция
* **Left shift (`a << k`)**: сдвигает биты числа x на k позиций влево
* **Right shift (`a << k`)**: сдвигает биты числа x на k позиций вправо

## Умножение на 2 в степени k

Чтобы выполнить умножение некоторого числа на 2 в степени k, достаточно выполнить над ним операцию побитового сдвига на k позиций влево

```python
a = 6
a = a << 3
# a is 48 now
```

## Деление на 2 в степени k

Чтобы выполнить деление некоторого числа на 2 в степени k, достаточно выполнить над ним операцию побитового сдвига на k позиций вправо

```python
a = 51
a = a >> 3
# a is 6 now
```

## Проверка, является ли число степенью 2

Brute force алгоритм с временной сложностью **O(log(n))**:

```python
def is_power_of_two(n: int) -> bool:
    if n == 0:
        return False
    while n % 2 == 0:
        n //= 2
    return True
```

Тот же результат можно достигнуть с помощью побитовых операций. Стоит учесть два свойства:

> Для любого числа X справедливо следующее: X и X-1 имеют одинаковые значения битов на всех позициях, кроме позиций самой правой единицы в X и всех битов правее этой единицы.

Decimal | Binary
------- | ------
420 | 110100**100**
419 | 110100**011**

> Любое число, являющееся степенью 2, в бинарном представлении имеет всего лишь одну единицу.

Получаем, что для числа, являющегося степенью двойки `x & (x - 1) == 0` .

Тот же алгоритм за **O(1)**:

```python
def is_power_of_two(n: int) -> bool:
    return n != 0 and not n & (n - 1)
```

## Подсчёт единиц в двоичном представлении числа

Как было сказано в предыдущем пункте, X и X-1 отличаются только начиная с самой правой единицы в X. Тогда, выполнив `x & (x - 1)` , получим число с кол-вом единиц меньшим на одну, чем в X:

Decimal | Binary
------- | ------
420 | 110100**100**
419 | 110100**011**
420 & 419 | 110100**000**

Получаем алгоритм сложностью **O(k)**, где k - кол-во единиц в двоичном представлении числа:

```python
def count_number_of_ones(n: int) -> int:
    count = 0
    while n:
        n &= n - 1
        count += 1
    return count
```

## Истинность i-го бита в двоичном представлении числа

Проверить, установлен ли i-ый бит числа X можно, выполнив `X & (1 << i)`.

`1 << i` является i-ой степенью двойки, все биты, кроме i-го, которой равны нулю. Значит при выполнении `X & (1 << i)` в результате мы будем иметь либо i-ю степень двойки (i-й бит числа X равен 1), либо 0.

```python
def check_bit_is_set(n: int, i: int) -> bool:
    return n & (1 << i) != 0
```

## Нахождение наибольшей степени двойки, меньшей, либо равной заданному числу

> Если все i бит числа N равны единице, занчит N = 2**i - 1. 

Например:

Decimal | Binary
------- | ------
15 | &nbsp;&nbsp;1111
16 | 10000

Если мы изменим все биты справа от самого старшего в числе X на единицу, то получим Y = X + (X-1) = 2 * x - 1.

Тогда искомым ответом будет являться (Y + 1) / 2 или (Y + 1) >> 1

Как заменить все биты  справа от самого старшего? Пусть мы имеем 1байтовый n = 2**7 или 10000000 в бинарном представлении.

Скопируем старший бит с помощью `n = n | (n >> 1)`:

Operation | Binary
------- | ------
n | 10000000
n >> 1 | &nbsp;&nbsp;1000000
n \| (n >> 1) | 11000000

Теперь то же саме, с помощью `n = n | (n >> 2)`:

Operation | Binary
------- | ------
n | 11000000
n >> 2 | &nbsp;&nbsp;&nbsp;&nbsp;110000
n \| (n >> 1) | 11110000

Продолжим с помощью `n = n | (n >> 4)`:

Operation | Binary
------- | ------
n | 11110000
n >> 4 | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1111
n \| (n >> 1) | 11111111

Получаем алгоритм для однобайовых значений n:

```python
def get_less_or_equal_power_of_two(n: int) -> int:
    n |= n >> 1
    n |= n >> 2
    n |= n >> 4

    return (n + 1) >> 1
```

## Получение самой правой единицы в двоичном представлении


Operation | Binary
------- | ------
420 | **110100**1**00**
420 & 419 | **110100**0**00**
420 ^ (420 & 419) | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1**00**

```python
def get_rightmost_one(n: int) -> int:
    return n ^ (n & (n - 1))
```

Ещё один вариант опирается на следуюее свойство:

>Для любого числа X и -X биты в их двоичных представлениях будут одинаковы до позиции самой правой единицы в X (включая её) и будут различны слева от позиции этой единицы.

```python
def get_rightmost_one(n: int) -> int:
    return n & (-n)
```

## Установка i-го бита числа

```python
def set_bit(n: int, i: int) -> int:
    return n | (1 << i)
```

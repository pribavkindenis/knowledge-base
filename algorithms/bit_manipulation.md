# Манипуляции с битами

[<< Алгоритмы](./content.md)

## Битовые операции

* **NOT (`~a`)**: логическое отрицание
* **AND (`a & b`)**: логическая конъюнкция
* **OR (`a | b`)**: логическая дизъюнкция
* **XOR (`a ^ b`)**: логическая исключающая дизъюнкция
* **Left shift (`a << k`)**: сдвигает биты числа x на k позиций влево
* **Right shift (`a << k`)**: сдвигает биты числа x на k позиций вправо

## Умножение на 2 в степени k

Чтобы выполнить умножение некоторого числа на 2 в степени k, достаточно выполнить над ним операцию побитового сдвига на k позиций влево

```python
a = 6
a = a << 3
# a is 48 now
```

## Деление на 2 в степени k

Чтобы выполнить деление некоторого числа на 2 в степени k, достаточно выполнить над ним операцию побитового сдвига на k позиций вправо

```python
a = 51
a = a >> 3
# a is 6 now
```

## Проверка, является ли число степенью 2

Brute force алгоритм с временной сложностью **O(log(n))**:

```python
def is_power_of_two(n: int) -> bool:
    if n == 0:
        return False
    while n % 2 == 0:
        n //= 2
    return True
```

Тот же результат можно достигнуть с помощью побитовых операций. Стоит учесть два свойства:

1) Для любого числа X справедливо следующее: X и X-1 имеют одинаковые значения битов на всех позициях, кроме позиций самой правой единицы в X и всех битов правее этой единицы.

Decimal | Binary
------- | ------
420 | 110100**100**
419 | 110100**011**

2) Любое число, являющееся степенью 2, в бинарном представлении имеет всего лишь одну единицу.

Получаем, что для числа, являющегося степенью двойки `x & (x - 1) == 0` .

Тот же алгоритм за **O(1)**:

```python
def is_power_of_two(n: int) -> bool:
    return n != 0 and not n & (n - 1)
```
